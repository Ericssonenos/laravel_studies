/* ============================================================
  Criação do schema auth
============================================================ */
CREATE SCHEMA IF NOT EXISTS auth;

/* ============================================================
  Função utilitária de atualização de timestamp (no schema auth)
============================================================ */
CREATE OR REPLACE FUNCTION auth.tg_set_dat_atualizado_em()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW IS DISTINCT FROM OLD THEN
    NEW.dat_atualizado_em := now();
  END IF;
  RETURN NEW;
END
$$;

/* Tabela: auth.locatarios */
CREATE TABLE IF NOT EXISTS auth.locatarios
(
    id_locatario bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    txt_nome_locatario character varying(120) COLLATE pg_catalog."default" NOT NULL,
    txt_descricao_locatario character varying(80) COLLATE pg_catalog."default" NOT NULL,
    dat_criado_em timestamp with time zone NOT NULL DEFAULT now(),
    dat_atualizado_em timestamp with time zone NOT NULL DEFAULT now(),
    dat_cancelamento_em timestamp with time zone,
    CONSTRAINT locatarios_pkey PRIMARY KEY (id_locatario),
    CONSTRAINT locatarios_txt_descricao_locatario_key UNIQUE (txt_descricao_locatario)
)
COMMENT ON TABLE  auth.locatarios IS 'PT: Locatários (multi-tenant). EN: Tenants (multi-tenant root).';
COMMENT ON COLUMN auth.locatarios.id_locatario                IS 'PT: PK do locatário. EN: Tenant primary key.';
COMMENT ON COLUMN auth.locatarios.txt_nome_locatario          IS 'PT: Nome do locatário. EN: Tenant name.';
COMMENT ON COLUMN auth.locatarios.txt_descricao_locatario    IS 'PT: Descrição do locatário. EN: Tenant description.';
COMMENT ON COLUMN auth.locatarios.dat_criado_em               IS 'PT: Criado em. EN: created_at.';
COMMENT ON COLUMN auth.locatarios.dat_atualizado_em           IS 'PT: Atualizado em. EN: updated_at.';
COMMENT ON COLUMN auth.locatarios.dat_cancelamento_em         IS 'PT: Cancelado em (soft delete). EN: canceled_at.';

/* Trigger PT: Atualiza "dat_atualizado_em" em UPDATE
          EN: Touches "updated_at" on UPDATE */
CREATE TRIGGER trg_locatarios_set_updated
BEFORE UPDATE ON auth.locatarios
FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();

/* =========
   Tabela: usuarios
   PT: Usuários do sistema
   EN: Users
========= */
CREATE TABLE IF NOT EXISTS auth.usuarios (
  id_usuario BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  locatario_id BIGINT NOT NULL,
  txt_nome_usuario VARCHAR(120) ,
  txt_email_usuario VARCHAR(160) NOT NULL,
  txt_senha_usuario VARCHAR(255) NOT NULL,
  flg_ativo_usuario boolean NOT NULL DEFAULT true,
  dat_criado_em timestamptz NOT NULL DEFAULT now(),
  dat_atualizado_em timestamptz NOT NULL DEFAULT now(),
  dat_cancelamento_em timestamptz,

  CONSTRAINT uq_usuarios_email_por_locatario UNIQUE (locatario_id, txt_email_usuario),
  CONSTRAINT fk_usuarios_locatarios
    FOREIGN KEY (locatario_id) REFERENCES auth.locatarios (id_locatario)
);
COMMENT ON TABLE  auth.usuarios IS 'PT: Usuários do sistema. EN: Users.';
COMMENT ON COLUMN auth.usuarios.id_usuario          IS 'PT: PK do usuário. EN: User primary key.';
COMMENT ON COLUMN auth.usuarios.locatario_id        IS 'PT: FK para locatários (N:1). EN: FK to tenants (many-to-one).';
COMMENT ON COLUMN auth.usuarios.txt_nome_usuario    IS 'PT: Nome do usuário. EN: User full name.';
COMMENT ON COLUMN auth.usuarios.txt_email_usuario   IS 'PT: E-mail de login (único por locatário). EN: Login email (tenant-scoped unique).';
COMMENT ON COLUMN auth.usuarios.txt_senha_usuario   IS 'PT: Hash da senha. EN: Password hash.';
COMMENT ON COLUMN auth.usuarios.flg_ativo_usuario   IS 'PT: Ativo? EN: Active flag.';
COMMENT ON COLUMN auth.usuarios.dat_criado_em       IS 'PT: Criado em. EN: created_at.';
COMMENT ON COLUMN auth.usuarios.dat_atualizado_em   IS 'PT: Atualizado em. EN: updated_at.';
COMMENT ON COLUMN auth.usuarios.dat_cancelamento_em IS 'PT: Cancelado em. EN: canceled_at.';
COMMENT ON CONSTRAINT uq_usuarios_email_por_locatario ON auth.usuarios
  IS 'PT: Garante e-mail único por locatário. EN: Enforces tenant-scoped email uniqueness.';
COMMENT ON CONSTRAINT fk_usuarios_locatarios ON auth.usuarios
  IS 'PT: N:1 usuários→locatários. EN: many-to-one users→tenants.';

CREATE TRIGGER trg_usuarios_set_updated
BEFORE UPDATE ON auth.usuarios
FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();

/* =======
   Tabela: grupos
   PT: Grupos/coleções de usuários
   EN: Groups (user collections)
======= */
CREATE TABLE IF NOT EXISTS auth.grupos (
  id_grupo BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  locatario_id BIGINT NOT NULL,
  txt_nome_grupo VARCHAR(120) NOT NULL,
  txt_descricao_grupo VARCHAR(255),
  flg_ativo_grupo boolean NOT NULL DEFAULT true,
  dat_criado_em timestamptz NOT NULL DEFAULT now(),
  dat_atualizado_em timestamptz NOT NULL DEFAULT now(),
  dat_cancelamento_em timestamptz,

  CONSTRAINT uq_grupos_nome_por_locatario UNIQUE (locatario_id, txt_nome_grupo),
  CONSTRAINT fk_grupos_locatarios
    FOREIGN KEY (locatario_id) REFERENCES auth.locatarios (id_locatario)
);
COMMENT ON TABLE  auth.grupos IS 'PT: Grupos de usuários. EN: User groups.';
COMMENT ON COLUMN auth.grupos.id_grupo               IS 'PT: PK do grupo. EN: Group primary key.';
COMMENT ON COLUMN auth.grupos.locatario_id           IS 'PT: FK para locatários. EN: FK to tenants.';
COMMENT ON COLUMN auth.grupos.txt_nome_grupo         IS 'PT: Nome do grupo. EN: Group name.';
COMMENT ON COLUMN auth.grupos.txt_descricao_grupo    IS 'PT: Descrição do grupo. EN: Group description.';
COMMENT ON COLUMN auth.grupos.flg_ativo_grupo        IS 'PT: Ativo? EN: Active flag.';
COMMENT ON COLUMN auth.grupos.dat_criado_em          IS 'PT: Criado em. EN: created_at.';
COMMENT ON COLUMN auth.grupos.dat_atualizado_em      IS 'PT: Atualizado em. EN: updated_at.';
COMMENT ON COLUMN auth.grupos.dat_cancelamento_em    IS 'PT: Cancelado em. EN: canceled_at.';
COMMENT ON CONSTRAINT uq_grupos_nome_por_locatario ON auth.grupos
  IS 'PT: Nome único por locatário. EN: Tenant-scoped unique name.';
COMMENT ON CONSTRAINT fk_grupos_locatarios ON auth.grupos
  IS 'PT: N:1 grupos→locatários. EN: many-to-one groups→tenants.';

CREATE TRIGGER trg_grupos_set_updated
BEFORE UPDATE ON auth.grupos
FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();

/* ======
   Tabela: papeis
   PT: Papéis/Funções de acesso
   EN: Roles (access levels)
====== */
CREATE TABLE IF NOT EXISTS auth.papeis (
  id_papel BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  locatario_id BIGINT NOT NULL,
  txt_nome_papel VARCHAR(120) NOT NULL,
  num_nivel_papel INTEGER NOT NULL DEFAULT 0,
  flg_ativo_papel boolean NOT NULL DEFAULT true,
  dat_criado_em timestamptz NOT NULL DEFAULT now(),
  dat_atualizado_em timestamptz NOT NULL DEFAULT now(),
  dat_cancelamento_em timestamptz,

  CONSTRAINT uq_papeis_nome_por_locatario UNIQUE (locatario_id, txt_nome_papel),
  CONSTRAINT fk_papeis_locatarios
    FOREIGN KEY (locatario_id) REFERENCES auth.locatarios (id_locatario)
);
COMMENT ON TABLE  auth.papeis IS 'PT: Papéis/funções de acesso. EN: Roles.';
COMMENT ON COLUMN auth.papeis.id_papel                IS 'PT: PK do papel. EN: Role primary key.';
COMMENT ON COLUMN auth.papeis.locatario_id            IS 'PT: FK para locatários. EN: FK to tenants.';
COMMENT ON COLUMN auth.papeis.txt_nome_papel          IS 'PT: Nome do papel. EN: Role name.';
COMMENT ON COLUMN auth.papeis.num_nivel_papel         IS 'PT: Nível hierárquico. EN: Hierarchy level.';
COMMENT ON COLUMN auth.papeis.flg_ativo_papel         IS 'PT: Ativo? EN: Active flag.';
COMMENT ON COLUMN auth.papeis.dat_criado_em           IS 'PT: Criado em. EN: created_at.';
COMMENT ON COLUMN auth.papeis.dat_atualizado_em       IS 'PT: Atualizado em. EN: updated_at.';
COMMENT ON COLUMN auth.papeis.dat_cancelamento_em     IS 'PT: Cancelado em. EN: canceled_at.';
COMMENT ON CONSTRAINT uq_papeis_nome_por_locatario ON auth.papeis
  IS 'PT: Nome único por locatário. EN: Tenant-scoped unique name.';
COMMENT ON CONSTRAINT fk_papeis_locatarios ON auth.papeis
  IS 'PT: N:1 papeis→locatários. EN: many-to-one roles→tenants.';

CREATE TRIGGER trg_papeis_set_updated
BEFORE UPDATE ON auth.papeis
FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();

/* ===========================
   Tabela: permissoes
   PT: Permissões atômicas
   EN: Permissions (atomic grants)
=========================== */
CREATE TABLE IF NOT EXISTS auth.permissoes (
  id_permissao BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  cod_permissao VARCHAR(160) NOT NULL UNIQUE,
  txt_descricao_permissao VARCHAR(255),
  flg_ativo_permissao boolean NOT NULL DEFAULT true,
  dat_criado_em timestamptz NOT NULL DEFAULT now(),
  dat_atualizado_em timestamptz NOT NULL DEFAULT now(),
  dat_cancelamento_em timestamptz
);
COMMENT ON TABLE  auth.permissoes IS 'PT: Permissões atômicas. EN: Atomic permissions.';
COMMENT ON COLUMN auth.permissoes.id_permissao             IS 'PT: PK da permissão. EN: Permission primary key.';
COMMENT ON COLUMN auth.permissoes.cod_permissao            IS 'PT: Código canônico (ex.: users.read). EN: Canonical permission code.';
COMMENT ON COLUMN auth.permissoes.txt_descricao_permissao  IS 'PT: Descrição. EN: Description.';
COMMENT ON COLUMN auth.permissoes.flg_ativo_permissao      IS 'PT: Ativo? EN: Active flag.';
COMMENT ON COLUMN auth.permissoes.dat_criado_em            IS 'PT: Criado em. EN: created_at.';
COMMENT ON COLUMN auth.permissoes.dat_atualizado_em        IS 'PT: Atualizado em. EN: updated_at.';
COMMENT ON COLUMN auth.permissoes.dat_cancelamento_em      IS 'PT: Cancelado em. EN: canceled_at.';

/* ==================
   Tabelas de relação (join tables)
   PT: Relacionamentos N:N
   EN: Many-to-many relationships
================== */

/* PT: Usuários ↔ Grupos (N:N)
   EN: Users ↔ Groups (M:N) */
CREATE TABLE IF NOT EXISTS auth.usuarios_grupos (
  usuario_id BIGINT NOT NULL, -- PT: FK usuário; EN: user_id
  grupo_id   BIGINT NOT NULL, -- PT: FK grupo;   EN: group_id

  dat_criado_em       timestamptz NOT NULL DEFAULT now(),
  dat_atualizado_em   timestamptz NOT NULL DEFAULT now(),
  dat_cancelamento_em timestamptz,

  PRIMARY KEY (usuario_id, grupo_id),

  CONSTRAINT fk_usuarios_grupos_usuarios
    FOREIGN KEY (usuario_id) REFERENCES auth.usuarios (id_usuario),
  CONSTRAINT fk_usuarios_grupos_grupos
    FOREIGN KEY (grupo_id)   REFERENCES auth.grupos   (id_grupo)
);
COMMENT ON TABLE  auth.usuarios_grupos IS 'PT: Relaciona usuários aos grupos (N:N). EN: Users-to-Groups join (M:N).';
COMMENT ON COLUMN auth.usuarios_grupos.usuario_id IS 'PT: FK usuário. EN: user_id.';
COMMENT ON COLUMN auth.usuarios_grupos.grupo_id   IS 'PT: FK grupo. EN: group_id.';
COMMENT ON COLUMN auth.usuarios_grupos.dat_criado_em        IS 'PT: Criado em. EN: created_at.';
COMMENT ON COLUMN auth.usuarios_grupos.dat_atualizado_em     IS 'PT: Atualizado em. EN: updated_at.';
COMMENT ON COLUMN auth.usuarios_grupos.dat_cancelamento_em   IS 'PT: Cancelado em. EN: canceled_at.';
COMMENT ON CONSTRAINT fk_usuarios_grupos_usuarios ON auth.usuarios_grupos
  IS 'PT: N:1 para usuários. EN: many-to-one to users.';
COMMENT ON CONSTRAINT fk_usuarios_grupos_grupos ON auth.usuarios_grupos
  IS 'PT: N:1 para grupos. EN: many-to-one to groups.';

CREATE TRIGGER trg_usuarios_grupos_set_updated
BEFORE UPDATE ON auth.usuarios_grupos
FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();

/* PT: Grupos ↔ Papéis (N:N)
   EN: Groups ↔ Roles (M:N) */
CREATE TABLE IF NOT EXISTS auth.grupos_papeis (
  grupo_id BIGINT NOT NULL, -- EN: group_id
  papel_id BIGINT NOT NULL, -- EN: role_id

  dat_criado_em       timestamptz NOT NULL DEFAULT now(),
  dat_atualizado_em   timestamptz NOT NULL DEFAULT now(),
  dat_cancelamento_em timestamptz,

  PRIMARY KEY (grupo_id, papel_id),

  CONSTRAINT fk_grupos_papeis_grupos
    FOREIGN KEY (grupo_id) REFERENCES auth.grupos (id_grupo),
  CONSTRAINT fk_grupos_papeis_papeis
    FOREIGN KEY (papel_id) REFERENCES auth.papeis (id_papel)
);
COMMENT ON TABLE  auth.grupos_papeis IS 'PT: Relaciona grupos a papéis (N:N). EN: Groups-to-Roles join (M:N).';
COMMENT ON COLUMN auth.grupos_papeis.grupo_id   IS 'PT: FK grupo. EN: group_id.';
COMMENT ON COLUMN auth.grupos_papeis.papel_id   IS 'PT: FK papel. EN: role_id.';
COMMENT ON COLUMN auth.grupos_papeis.dat_criado_em        IS 'PT: Criado em. EN: created_at.';
COMMENT ON COLUMN auth.grupos_papeis.dat_atualizado_em     IS 'PT: Atualizado em. EN: updated_at.';
COMMENT ON COLUMN auth.grupos_papeis.dat_cancelamento_em   IS 'PT: Cancelado em. EN: canceled_at.';

CREATE TRIGGER trg_grupos_papeis_set_updated
BEFORE UPDATE ON auth.grupos_papeis
FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();

/* PT: Papéis ↔ Permissões (N:N)
   EN: Roles ↔ Permissions (M:N) */
CREATE TABLE IF NOT EXISTS auth.papeis_permissoes (
  papel_id     BIGINT NOT NULL, -- EN: role_id
  permissao_id BIGINT NOT NULL, -- EN: permission_id

  dat_criado_em       timestamptz NOT NULL DEFAULT now(),
  dat_atualizado_em   timestamptz NOT NULL DEFAULT now(),
  dat_cancelamento_em timestamptz,

  PRIMARY KEY (papel_id, permissao_id),

  CONSTRAINT fk_papeis_permissoes_papeis
    FOREIGN KEY (papel_id)     REFERENCES auth.papeis      (id_papel),
  CONSTRAINT fk_papeis_permissoes_permissoes
    FOREIGN KEY (permissao_id) REFERENCES auth.permissoes  (id_permissao)
);
COMMENT ON TABLE  auth.papeis_permissoes IS 'PT: Relaciona papéis a permissões (N:N). EN: Roles-to-Permissions join (M:N).';
COMMENT ON COLUMN auth.papeis_permissoes.papel_id     IS 'PT: FK papel. EN: role_id.';
COMMENT ON COLUMN auth.papeis_permissoes.permissao_id IS 'PT: FK permissão. EN: permission_id.';
COMMENT ON COLUMN auth.papeis_permissoes.dat_criado_em        IS 'PT: Criado em. EN: created_at.';
COMMENT ON COLUMN auth.papeis_permissoes.dat_atualizado_em     IS 'PT: Atualizado em. EN: updated_at.';
COMMENT ON COLUMN auth.papeis_permissoes.dat_cancelamento_em   IS 'PT: Cancelado em. EN: canceled_at.';

CREATE TRIGGER trg_papeis_permissoes_set_updated
BEFORE UPDATE ON auth.papeis_permissoes
FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();

/* PT: Usuários ↔ Permissões (N:N) com "flg_permitir"
   EN: Users ↔ Permissions (M:N) with allow/deny flag */
CREATE TABLE IF NOT EXISTS auth.usuarios_permissoes (
  usuario_id   BIGINT  NOT NULL, -- EN: user_id
  permissao_id BIGINT  NOT NULL, -- EN: permission_id

  /* PT: true=permitir, false=negar (útil para exceções).
     EN: true=allow, false=deny (useful for exceptions). */
  flg_permitir boolean NOT NULL DEFAULT true,

  dat_criado_em       timestamptz NOT NULL DEFAULT now(),
  dat_atualizado_em   timestamptz NOT NULL DEFAULT now(),
  dat_cancelamento_em timestamptz,

  PRIMARY KEY (usuario_id, permissao_id),

  CONSTRAINT fk_usuarios_permissoes_usuarios
    FOREIGN KEY (usuario_id)   REFERENCES auth.usuarios   (id_usuario),
  CONSTRAINT fk_usuarios_permissoes_permissoes
    FOREIGN KEY (permissao_id) REFERENCES auth.permissoes (id_permissao)
);
COMMENT ON TABLE  auth.usuarios_permissoes IS 'PT: Permissões específicas por usuário (N:N). EN: User-specific permissions (M:N).';
COMMENT ON COLUMN auth.usuarios_permissoes.usuario_id   IS 'PT: FK usuário. EN: user_id.';
COMMENT ON COLUMN auth.usuarios_permissoes.permissao_id IS 'PT: FK permissão. EN: permission_id.';
COMMENT ON COLUMN auth.usuarios_permissoes.flg_permitir IS 'PT: Permitir? (true=permitir, false=negar). EN: Allow flag.';
COMMENT ON COLUMN auth.usuarios_permissoes.dat_criado_em        IS 'PT: Criado em. EN: created_at.';
COMMENT ON COLUMN auth.usuarios_permissoes.dat_atualizado_em     IS 'PT: Atualizado em. EN: updated_at.';
COMMENT ON COLUMN auth.usuarios_permissoes.dat_cancelamento_em   IS 'PT: Cancelado em. EN: canceled_at.';

CREATE TRIGGER trg_usuarios_permissoes_set_updated
BEFORE UPDATE ON auth.usuarios_permissoes
FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();

/* PT: Usuários ↔ Papéis (N:N)
   EN: Users ↔ Roles (M:N) */
CREATE TABLE IF NOT EXISTS auth.usuarios_papeis (
  usuario_id BIGINT NOT NULL, -- EN: user_id
  papel_id   BIGINT NOT NULL, -- EN: role_id

  dat_criado_em       timestamptz NOT NULL DEFAULT now(),
  dat_atualizado_em   timestamptz NOT NULL DEFAULT now(),
  dat_cancelamento_em timestamptz,

  PRIMARY KEY (usuario_id, papel_id),

  CONSTRAINT fk_usuarios_papeis_usuarios
    FOREIGN KEY (usuario_id) REFERENCES auth.usuarios (id_usuario),
  CONSTRAINT fk_usuarios_papeis_papeis
    FOREIGN KEY (papel_id)   REFERENCES auth.papeis   (id_papel)
);
COMMENT ON TABLE  auth.usuarios_papeis IS 'PT: Relaciona usuários a papéis (N:N). EN: Users-to-Roles join (M:N).';
COMMENT ON COLUMN auth.usuarios_papeis.usuario_id   IS 'PT: FK usuário. EN: user_id.';
COMMENT ON COLUMN auth.usuarios_papeis.papel_id     IS 'PT: FK papel. EN: role_id.';
COMMENT ON COLUMN auth.usuarios_papeis.dat_criado_em        IS 'PT: Criado em. EN: created_at.';
COMMENT ON COLUMN auth.usuarios_papeis.dat_atualizado_em     IS 'PT: Atualizado em. EN: updated_at.';
COMMENT ON COLUMN auth.usuarios_papeis.dat_cancelamento_em   IS 'PT: Cancelado em. EN: canceled_at.';

CREATE TRIGGER trg_usuarios_papeis_set_updated
BEFORE UPDATE ON auth.usuarios_papeis
FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();

/* ==========
   Tabela: auditorias
   PT: Trilhas de auditoria / logs de ações
   EN: Audit trails / action logs
========== */
CREATE TABLE IF NOT EXISTS auth.auditorias (
  id_auditoria BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  locatario_id BIGINT NOT NULL,
  usuario_id BIGINT,
  txt_acao_auditoria VARCHAR(120) NOT NULL,
  txt_recurso_auditoria VARCHAR(160),
  txt_endereco_ip VARCHAR(64),
  txt_agente_http VARCHAR(255),
  jsn_contexto jsonb,
  dat_criado_em timestamptz NOT NULL DEFAULT now(),
  dat_atualizado_em timestamptz NOT NULL DEFAULT now(),
  dat_cancelamento_em timestamptz,

  CONSTRAINT fk_auditorias_locatarios
    FOREIGN KEY (locatario_id) REFERENCES auth.locatarios (id_locatario),
  CONSTRAINT fk_auditorias_usuarios
    FOREIGN KEY (usuario_id)   REFERENCES auth.usuarios  (id_usuario)
);
COMMENT ON TABLE  auth.auditorias IS 'PT: Auditoria de ações. EN: Audit trail.';
COMMENT ON COLUMN auth.auditorias.id_auditoria          IS 'PT: PK da auditoria. EN: Audit primary key.';
COMMENT ON COLUMN auth.auditorias.locatario_id          IS 'PT: FK locatário. EN: Tenant FK.';
COMMENT ON COLUMN auth.auditorias.usuario_id            IS 'PT: FK usuário (ator). EN: Actor user FK.';
COMMENT ON COLUMN auth.auditorias.txt_acao_auditoria    IS 'PT: Ação registrada. EN: Action key.';
COMMENT ON COLUMN auth.auditorias.txt_recurso_auditoria IS 'PT: Recurso alvo. EN: Target resource.';
COMMENT ON COLUMN auth.auditorias.txt_endereco_ip       IS 'PT: Endereço IP. EN: IP address.';
COMMENT ON COLUMN auth.auditorias.txt_agente_http       IS 'PT: Agente HTTP. EN: HTTP user agent.';
COMMENT ON COLUMN auth.auditorias.jsn_contexto          IS 'PT: Contexto JSON. EN: JSON context.';
COMMENT ON COLUMN auth.auditorias.dat_criado_em         IS 'PT: Criado em. EN: created_at.';
COMMENT ON COLUMN auth.auditorias.dat_atualizado_em     IS 'PT: Atualizado em. EN: updated_at.';
COMMENT ON COLUMN auth.auditorias.dat_cancelamento_em   IS 'PT: Cancelado em. EN: canceled_at.';
COMMENT ON CONSTRAINT fk_auditorias_locatarios ON auth.auditorias
  IS 'PT: N:1 auditorias→locatários. EN: many-to-one audits→tenants.';
COMMENT ON CONSTRAINT fk_auditorias_usuarios ON auth.auditorias
  IS 'PT: N:1 auditorias→usuários (opcional). EN: many-to-one audits→users (optional).';

/* Criação dos triggers com verificação condicional */
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_locatarios_set_updated') THEN
    CREATE TRIGGER trg_locatarios_set_updated BEFORE UPDATE ON auth.locatarios FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_usuarios_set_updated') THEN
    CREATE TRIGGER trg_usuarios_set_updated BEFORE UPDATE ON auth.usuarios FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_grupos_set_updated') THEN
    CREATE TRIGGER trg_grupos_set_updated BEFORE UPDATE ON auth.grupos FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_papeis_set_updated') THEN
    CREATE TRIGGER trg_papeis_set_updated BEFORE UPDATE ON auth.papeis FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_permissoes_set_updated') THEN
    CREATE TRIGGER trg_permissoes_set_updated BEFORE UPDATE ON auth.permissoes FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_usuarios_grupos_set_updated') THEN
    CREATE TRIGGER trg_usuarios_grupos_set_updated BEFORE UPDATE ON auth.usuarios_grupos FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_grupos_papeis_set_updated') THEN
    CREATE TRIGGER trg_grupos_papeis_set_updated BEFORE UPDATE ON auth.grupos_papeis FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_papeis_permissoes_set_updated') THEN
    CREATE TRIGGER trg_papeis_permissoes_set_updated BEFORE UPDATE ON auth.papeis_permissoes FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_usuarios_permissoes_set_updated') THEN
    CREATE TRIGGER trg_usuarios_permissoes_set_updated BEFORE UPDATE ON auth.usuarios_permissoes FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_usuarios_papeis_set_updated') THEN
    CREATE TRIGGER trg_usuarios_papeis_set_updated BEFORE UPDATE ON auth.usuarios_papeis FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_auditorias_set_updated') THEN
    CREATE TRIGGER trg_auditorias_set_updated BEFORE UPDATE ON auth.auditorias FOR EACH ROW EXECUTE FUNCTION auth.tg_set_dat_atualizado_em();
  END IF;
END
$$;

/* Índices */
CREATE INDEX IF NOT EXISTS ix_auditorias_locatario_criado_em ON auth.auditorias (locatario_id, dat_criado_em);
CREATE INDEX IF NOT EXISTS ix_auditorias_jsn_contexto ON auth.auditorias USING GIN (jsn_contexto);

/* Confirmar criação */
SELECT 'Schema auth criado com sucesso!' AS status;
SELECT schemaname, tablename FROM pg_tables WHERE schemaname = 'auth' ORDER BY tablename;
